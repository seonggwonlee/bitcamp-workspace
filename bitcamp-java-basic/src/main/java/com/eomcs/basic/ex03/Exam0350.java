// 주제: 부동소수점의 정규화 = 2진수로 바꾸기

package com.eomcs.basic.ex03;


class Exam0350 { 
    public static void main(String[] args) { 
        System.out.println(12.375f); // 32비트 부동소수점
        System.out.println(12.375); // 64비트 부동소수점
        System.out.println(-12.375);

        // 12.375(부동소수점) 정규화 결과값
        // ==> IEEE 754 규정에 따라 부동 소수점을 2진수로 변환한다.
        // ==> 01000001 01000110 00000000 00000000 (2진수)
        // ==> 41460000(16진수)
     }
}

// 방법
// 1) 소수점 이상 부분을 2진수로 변환 후 (12.375중 12부분)
//  - 1100(2진수

// 2) 소수점 이하 부분을 2진수로 변환 (12.375중 .375부분)
//  - 소수점 각각 2로 곱하여 나온 결과에서 정수 부분만 차례대로 사용한다.
//  - 소수 부분이 0이거나 반복되면 계산을 멈춘다.
//  - 예: 0.375(10진수)
// 0.375 * 2 = 0.75 (0)
// 0.75 * 2 = 1.5 (1)
// 0.5 * 2 = 1.0 (1)
// ==> 0.011(2진수)

// 3) 소수점 이상 2진수와 소수점 이하 2진수를 합한다.
// ==> 12(1100) + .375(0.011) = 1100.011

// 4) 정규화
// => 소수점 위치를 조정하여 가수부와 지수부를 분리한다.
//  4-1) 소수점 왼쪽에 1만 남도록 소수점을 이동한다.
//      => 1.100011 * 2의 3승 = 1100.011
//  4-2) 소수점 앞 1은 무조건 1이기 때문에 버린다.
//      => 100011 * 2의 3승
//  4-3) 가수부와 지수부로 분리한다.
//      가수부 : 100011 (Sign-Magnitude로 표현한다.) -> 음수나 양수나 같은 2진수 값을 갖는다. ex) 100011
//      지수부 : 100011 (2의 제곱승 값이다) -> Excess-K로 표현한다. K값은 127이다. ex) 3(2의 제곱승) + 127(K값 : bias) = 130 = 10000010(2진수)
//  4-4) 32비트 메모리에 담기
//      - [1:부호비트][8:지수부][23:가수부] = 총 32비트
//      - ex) 0(부호비트)10000010(지수부)10001100000000000000000(가수부, 나머지는 0으로 채워짐) => 01000001_01000110_00000000_000000000_00000000 => 41_46_00_00(16진수)
//  4-5) 64비트 메모리에 담기
//      - [1:부호비트][11:지수부][52:가수부] = 총 64비트
//      - ex) 0(부호비트)00010000010(지수부)1000110000000000000000000000000000000000000000000000(가수부, 나머지는 0으로 채워짐) 
//      => 00001000_00101000_11000000_00000000_00000000_00000000_00000000_00000000
//      => 08_28_c0_00_00_00_00_00(16진수)
