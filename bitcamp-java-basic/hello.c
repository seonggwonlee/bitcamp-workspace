#include <stdio.h>
#include <stdlib.h>

int main(){
  int i[3]; // int 변수를 연속되게 3개 만든다.
  
    i[0] = 100;
    i[1] = 200;
    i[2] = 300;  
     printf("%d, %d, %d\n", i[0], i[1], i[2]);
      
    int* p;
    
    p = &i[0]; // i라는 배열의 1번 메모리의 주소(해당 메모리의 값이 아닌)를 p에 담는다.
      printf("%d\n", *p); // 1번 주소의 값을 출력한다.
    
    p = &i[1]; // i라는 배열의 2번 메모리의 주소를 p에 담는다.
      printf("%d\n", *p);
    
    p = &i[2]; // i라는 배열의 3번 메모리의 주소를 p에 담는다.
      printf("%d\n", *p);
      
    p = i; // C에서는 배열 이름 자체가 배열의 시작 주소를 가리키기도 한다 (=&i[0]).
      printf("%d\n", *p);
      
    p = i; 
      printf("%d\n", *(p+0)); // C에서는 주소 연산이 가능하다. (자바는 불가능)
      
    p = i;  
      printf("%d\n", *(p+1)); // 여기서 1은 숫자 1 증가가 아닌, 1단위로 증가하라는 뜻
    
    p = i;  
      printf("%d\n", *(p+2)); // 여기서 2는 숫자 2 증가가 아닌, 1단위로 증가하라는 뜻
  
    
    //byte* p2 = (byte*)malloc(12); // "바이트"단위로 다룰 12바이트의 "byte"메모리 생성
    int* p2 = (byte*)malloc(sizeof(int) * 3); 
    //int* p2 = (int*)malloc(12); // "4바이트"단위로 다룰 12바이트의 "int"메모리 생성
    
    *p2 = 110; // p2 메모리에 찾아가서 110을 집어넣어라
    *(p2 + 1) = 220; // p2 메모리 +1단위로 찾아가서 220을 집어넣어라
    *(p2 + 2) = 330; // p2 메모리 +2단위로 찾아가서 330을 집어넣어라 (int단위로 다룬다면 총 3개의 메모리 중 마지막이 된다.)
    
      printf("%d, %d, %d\n", *p2, *(p2 + 1), *(p2 + 2));
      printf("%d, %d, %d\n", p2[0], p2[1], p2[2]); // c에선 배열 선언을 하지 않아도 배열처럼 쓸 수 있다.
      
      printf("%d\n", *(p2+3)); // 빈 영역의 메모리이므로 쓰레기값이 출력된다. 만약 해당 부분이 권한외 메모리 영역이라면 치명적 오류 발생함
      // 그만큼 C는 주소 지정 및 사용에 있어 굉장히 개방적이고 자유롭다. 
      printf("%d\n", p2[3]);
    
    free(p2); // malloc 해제
    
      printf("%d, %d, %d\n", *p2, *(p2 + 1), *(p2 + 2)); // 해제된 malloc를 다시 사용 --> C는 해당 사항을 제약하지 못한다. 
    
    return 0;
}